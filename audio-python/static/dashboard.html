<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PIMIC Audio Dashboard</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        }
        
        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .server-info {
            display: flex;
            justify-content: center;
            gap: 30px;
            flex-wrap: wrap;
            margin-top: 15px;
        }
        
        .info-item {
            background: rgba(255, 255, 255, 0.2);
            padding: 10px 20px;
            border-radius: 10px;
            font-weight: bold;
        }
        
        .status-online { color: #4ECDC4; }
        .status-offline { color: #FF6B6B; }
        .status-warning { color: #FFE66D; }
        
        .controls {
            text-align: center;
            margin-bottom: 30px;
        }
        
        .btn {
            background: linear-gradient(45deg, #FF6B6B, #4ECDC4);
            border: none;
            padding: 12px 25px;
            border-radius: 25px;
            color: white;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin: 0 10px;
        }
        
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .streams-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stream-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            transition: all 0.3s ease;
        }
        
        .stream-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 12px 40px rgba(0, 0, 0, 0.2);
        }
        
        .stream-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .client-info {
            display: flex;
            flex-direction: column;
        }
        
        .client-ip {
            font-size: 1.3em;
            font-weight: bold;
            color: #4ECDC4;
        }
        
        .client-details {
            font-size: 0.9em;
            opacity: 0.8;
            margin-top: 5px;
        }
        
        .stream-status {
            padding: 5px 12px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: bold;
        }
        
        .status-active {
            background: rgba(76, 204, 196, 0.3);
            color: #4ECDC4;
        }
        
        .status-inactive {
            background: rgba(255, 107, 107, 0.3);
            color: #FF6B6B;
        }
        
        .audio-controls {
            margin: 15px 0;
        }
        
        .control-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }
        
        .control-btn {
            background: linear-gradient(45deg, #667eea, #764ba2);
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            cursor: pointer;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 80px;
        }
        
        .control-btn:hover {
            transform: scale(1.05);
        }
        
        .control-btn:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }
        
        .audio-player {
            width: 100%;
            margin: 10px 0;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }
        
        .enhanced-player {
            background: linear-gradient(135deg, rgba(255, 230, 109, 0.1), rgba(44, 62, 80, 0.1));
            border: 1px solid rgba(255, 230, 109, 0.3);
            border-radius: 15px;
            padding: 20px;
            margin: 15px 0;
        }
        
        .player-visualizer {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .visualizer-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        .player-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
        }
        
        .player-time {
            display: flex;
            align-items: center;
            gap: 10px;
            font-family: monospace;
            font-size: 0.9em;
            color: #FFE66D;
        }
        
        .player-progress {
            flex: 1;
            margin: 0 15px;
        }
        
        .progress-bar {
            width: 100%;
            height: 8px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 4px;
            overflow: hidden;
            cursor: pointer;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #FFE66D, #FF6B6B);
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .volume-visualizer {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .volume-bars {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 20px;
        }
        
        .volume-bar {
            width: 3px;
            background: #FFE66D;
            border-radius: 1px;
            transition: height 0.1s ease;
        }
        
        .rtp-info {
            background: rgba(255, 107, 107, 0.1);
            border: 1px solid rgba(255, 107, 107, 0.3);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
        }
        
        .rtp-controls {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }
        
        .rtp-status {
            color: #FF6B6B;
            font-weight: bold;
        }
        
        .live-soundwave {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            height: 80px;
            position: relative;
            overflow: hidden;
        }
        
        .soundwave-canvas {
            width: 100%;
            height: 100%;
            border-radius: 4px;
        }
        
        .soundwave-info {
            position: absolute;
            top: 5px;
            right: 8px;
            font-size: 0.75em;
            color: #FFE66D;
            background: rgba(0, 0, 0, 0.6);
            padding: 2px 6px;
            border-radius: 4px;
        }
        
        .level-indicators {
            display: flex;
            gap: 2px;
            align-items: flex-end;
            height: 30px;
            margin: 5px 0;
        }
        
        .level-bar {
            width: 4px;
            background: linear-gradient(to top, #4ECDC4, #FFE66D, #FF6B6B);
            border-radius: 2px;
            transition: height 0.1s ease;
            min-height: 2px;
            opacity: 0.8;
        }
        
        .audio-status {
            font-size: 0.8em;
            color: #FFE66D;
            margin-top: 5px;
            display: flex;
            justify-content: space-between;
        }
        
        .stream-info {
            background: rgba(0, 0, 0, 0.2);
            padding: 10px;
            border-radius: 8px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin: 3px 0;
        }
        
        .no-streams {
            text-align: center;
            padding: 60px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(10px);
        }
        
        .no-streams h2 {
            color: #FFE66D;
            margin-bottom: 15px;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            font-size: 1.2em;
        }
        
        .error {
            background: rgba(255, 107, 107, 0.3);
            border: 1px solid #FF6B6B;
            padding: 15px;
            border-radius: 10px;
            margin: 10px 0;
        }
        
        .volume-control {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
        }
        
        .volume-slider {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
            cursor: pointer;
        }
        
        @media (max-width: 768px) {
            .streams-container {
                grid-template-columns: 1fr;
            }
            
            .server-info {
                flex-direction: column;
                gap: 10px;
            }
            
            .control-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üéµ PIMIC Audio Dashboard</h1>
        <div class="server-info">
            <div class="info-item">
                <span>Server:</span> <span id="serverStatus" class="status-offline">Pr√ºfen...</span>
            </div>
            <div class="info-item">
                <span>Aktive Streams:</span> <span id="streamCount">-</span>
            </div>
            <div class="info-item">
                <span>Verbindungen:</span> <span id="connectionCount">-</span>
            </div>
            <div class="info-item">
                <span>Letztes Update:</span> <span id="lastUpdate">-</span>
            </div>
        </div>
    </div>
    
    <div class="controls">
        <button class="btn" onclick="refreshStreams()">üîÑ Aktualisieren</button>
        <button class="btn" onclick="toggleAutoRefresh()" id="autoRefreshBtn">‚è∏Ô∏è Auto-Refresh</button>
        <button class="btn" onclick="stopAllStreams()">‚èπÔ∏è Alle stoppen</button>
    </div>
    
    <div id="streamsContainer" class="streams-container">
        <div class="loading">üîÑ Lade Streams...</div>
    </div>

    <script>
        let autoRefreshInterval = null;
        let isAutoRefresh = true;
        let streamPlayers = new Map();
        
        // Auto-detect protocol and port
        const isHTTPS = window.location.protocol === 'https:';
        const isHTTPDashboard = window.location.port === '8081';
        
        // If running on HTTP dashboard (port 8081), prefer HTTP API, otherwise use HTTPS
        const SERVER_BASE = isHTTPDashboard ? 'http://192.168.188.90:8081' : 'https://192.168.188.90:6969';
        const HTTP_FALLBACK = 'http://192.168.188.90:8081';
        const HTTPS_FALLBACK = 'https://192.168.188.90:6969';
        
        // Initialize dashboard
        async function initDashboard() {
            await refreshStreams();
            startAutoRefresh();
        }
        
        // Refresh stream data
        async function refreshStreams() {
            let serverBase = SERVER_BASE;
            
            try {
                // Try primary protocol first, then fallback
                let healthResponse, streamsResponse;
                
                try {
                    [healthResponse, streamsResponse] = await Promise.all([
                        fetch(`${SERVER_BASE}/health`),
                        fetch(`${SERVER_BASE}/api/streams`)
                    ]);
                } catch (primaryError) {
                    console.log('Primary server failed, trying fallback');
                    // If we're on HTTP dashboard, try HTTPS fallback, otherwise try HTTP fallback
                    const fallbackUrl = isHTTPDashboard ? HTTPS_FALLBACK : HTTP_FALLBACK;
                    serverBase = fallbackUrl;
                    [healthResponse, streamsResponse] = await Promise.all([
                        fetch(`${fallbackUrl}/health`),
                        fetch(`${fallbackUrl}/api/streams`)
                    ]);
                }
                
                const health = await healthResponse.json();
                const streams = await streamsResponse.json();
                
                updateServerInfo(health, streams, serverBase);
                updateStreamCards(streams, serverBase);
                
            } catch (error) {
                console.error('Error refreshing streams:', error);
                showError('Fehler beim Laden der Streams: ' + error.message);
                updateServerStatus('offline');
            }
        }
        
        // Update server information
        function updateServerInfo(health, streams, serverBase) {
            const serverStatus = document.getElementById('serverStatus');
            const streamCount = document.getElementById('streamCount');
            const connectionCount = document.getElementById('connectionCount');
            const lastUpdate = document.getElementById('lastUpdate');
            
            if (health.status === 'healthy') {
                const protocol = serverBase.includes('https') ? 'HTTPS' : 'HTTP';
                serverStatus.textContent = `Online (${protocol})`;
                serverStatus.className = 'status-online';
            } else {
                serverStatus.textContent = 'Probleme';
                serverStatus.className = 'status-warning';
            }
            
            streamCount.textContent = streams.totalStreams || 0;
            connectionCount.textContent = health.connected_clients || 0;
            lastUpdate.textContent = new Date().toLocaleTimeString();
        }
        
        // Update server status only
        function updateServerStatus(status) {
            const serverStatus = document.getElementById('serverStatus');
            if (status === 'offline') {
                serverStatus.textContent = 'Offline';
                serverStatus.className = 'status-offline';
            }
        }
        
        // Update stream cards
        async function updateStreamCards(data, serverBase) {
            const container = document.getElementById('streamsContainer');
            
            // Use API data if available, otherwise fallback to client detection
            let activeClients = [];
            
            if (data && data.streams && data.streams.length > 0) {
                // Validate that API streams are actually available
                console.log('API shows streams, validating availability...');
                const validatedClients = [];
                
                for (const stream of data.streams) {
                    try {
                        // Always validate against HTTPS server (port 6969) where streams actually exist
                        const streamUrl = `https://${window.location.hostname}:6969/client/${stream.client_ip}/stream`;
                        const response = await fetch(streamUrl, { method: 'HEAD' });
                        if (response.ok) {
                            validatedClients.push(stream.client_ip);
                            console.log(`‚úÖ Stream verified for ${stream.client_ip}`);
                        } else {
                            console.log(`‚ùå Stream not available for ${stream.client_ip} (${response.status})`);
                        }
                    } catch (error) {
                        console.log(`‚ùå Stream validation failed for ${stream.client_ip}:`, error.message);
                    }
                }
                activeClients = validatedClients;
            } else {
                // Fallback: Find active clients by checking recent activity
                activeClients = await findActiveClients(serverBase);
            }
            
            if (activeClients.length === 0) {
                container.innerHTML = `
                    <div class="no-streams">
                        <h2>üìµ Keine aktiven Streams</h2>
                        <p>Starte die Mikrofon-App auf einem Client, um Streams zu sehen.</p>
                        <p>Oder besuche: <code>${serverBase || SERVER_BASE}</code></p>
                    </div>
                `;
                return;
            }
            
            const streamCards = activeClients.map(clientIP => createStreamCard(clientIP, serverBase)).join('');
            container.innerHTML = streamCards;
        }
        
        // Find active clients by testing stream endpoints
        async function findActiveClients(serverBase) {
            const knownClients = ['192.168.188.28', '192.168.188.49']; // Add known clients
            const activeClients = [];
            
            for (const clientIP of knownClients) {
                try {
                    // Always check HTTPS server for streams (port 6969)
                    const streamBaseUrl = `https://${window.location.hostname}:6969`;
                    const response = await fetch(`${streamBaseUrl}/client/${clientIP}/stream`, {
                        method: 'HEAD'
                    });
                    if (response.ok) {
                        activeClients.push(clientIP);
                    }
                } catch (error) {
                    // Client not active or network error
                    console.log(`Client ${clientIP} not available:`, error.message);
                }
            }
            
            return activeClients;
        }
        
        // Create stream card HTML
        function createStreamCard(clientIP, serverBase) {
            const playerId = `player_${clientIP.replace(/\./g, '_')}`;
            const cardId = `card_${clientIP.replace(/\./g, '_')}`;
            
            return `
                <div class="stream-card" id="${cardId}">
                    <div class="stream-header">
                        <div class="client-info">
                            <div class="client-ip">üñ•Ô∏è ${clientIP}</div>
                            <div class="client-details">
                                <span id="status_${playerId}">Bereit</span> ‚Ä¢ 
                                <span id="format_${playerId}">WebM/Opus</span>
                            </div>
                        </div>
                        <div class="stream-status status-active">üü¢ Aktiv</div>
                    </div>
                    
                    <!-- Live Soundwave (always visible) -->
                    <div class="live-soundwave">
                        <canvas id="soundwave_${playerId}" class="soundwave-canvas"></canvas>
                        <div class="soundwave-info" id="soundwaveInfo_${playerId}">üîá Kein Signal</div>
                        <div class="level-indicators" id="levelBars_${playerId}">
                            ${Array.from({length: 20}, (_, i) => `<div class="level-bar" style="height: 2px;"></div>`).join('')}
                        </div>
                        <div class="audio-status">
                            <span id="audioLevel_${playerId}">Level: 0%</span>
                            <span id="audioPeak_${playerId}">Peak: 0%</span>
                        </div>
                    </div>
                    
                    <div class="enhanced-player">
                        <!-- Visualizer -->
                        <div class="player-visualizer">
                            <canvas id="visualizer_${playerId}" class="visualizer-canvas"></canvas>
                        </div>
                        
                        <!-- Player Controls -->
                        <div class="player-controls">
                            <div class="control-buttons">
                                <button class="control-btn" onclick="playEnhancedStream('${clientIP}', '${playerId}', '${serverBase}')">
                                    ‚ñ∂Ô∏è
                                </button>
                                <button class="control-btn" onclick="pauseEnhancedStream('${playerId}')">
                                    ‚è∏Ô∏è
                                </button>
                                <button class="control-btn" onclick="stopEnhancedStream('${playerId}')">
                                    ‚èπÔ∏è
                                </button>
                                <button class="control-btn" onclick="refreshStream('${clientIP}', '${playerId}')">
                                    üîÑ
                                </button>
                            </div>
                            
                            <div class="player-progress">
                                <div class="progress-bar" onclick="seekStream('${playerId}', event)">
                                    <div id="progress_${playerId}" class="progress-fill"></div>
                                </div>
                            </div>
                            
                            <div class="player-time">
                                <span id="time_${playerId}">00:00</span>
                            </div>
                        </div>
                        
                        <!-- Volume Control with Visualizer -->
                        <div class="volume-visualizer">
                            <span>üîä</span>
                            <input type="range" class="volume-slider" min="0" max="100" value="80" 
                                   onchange="setEnhancedVolume('${playerId}', this.value)">
                            <span id="volume_${playerId}">80%</span>
                            <div class="volume-bars" id="volumeBars_${playerId}">
                                ${Array.from({length: 10}, (_, i) => `<div class="volume-bar" style="height: 2px;"></div>`).join('')}
                            </div>
                        </div>
                        
                        <!-- Hidden audio element for actual playback -->
                        <audio id="${playerId}" preload="none" style="display: none;">
                            <source type="audio/webm">
                        </audio>
                    </div>
                    
                    <div class="stream-info">
                        <div class="info-row">
                            <span>Status:</span>
                            <span id="info_${playerId}">Bereit</span>
                        </div>
                        <div class="info-row">
                            <span>Stream URL:</span>
                            <span style="font-family: monospace; font-size: 0.8em;">/client/${clientIP}/stream</span>
                        </div>
                        <div class="info-row">
                            <span>Letzter Refresh:</span>
                            <span id="refresh_${playerId}">-</span>
                        </div>
                    </div>
                    
                    <!-- RTP Stream Information -->
                    <div class="rtp-info">
                        <div class="info-row">
                            <span>üåê RTP Stream:</span>
                            <span class="rtp-status" id="rtpStatus_${playerId}">Gestoppt</span>
                        </div>
                        <div class="info-row">
                            <span>RTP URL:</span>
                            <span style="font-family: monospace; font-size: 0.8em;" id="rtpUrl_${playerId}">rtp://192.168.188.90:5004</span>
                        </div>
                        <div class="rtp-controls">
                            <button class="control-btn" onclick="startRTPStream('${clientIP}', '${playerId}')">
                                üì° RTP Start
                            </button>
                            <button class="control-btn" onclick="stopRTPStream('${clientIP}', '${playerId}')">
                                ‚èπÔ∏è RTP Stop
                            </button>
                            <button class="control-btn" onclick="copyRTPUrl('${clientIP}', '${playerId}')">
                                üìã URL kopieren
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Play stream
        async function playStream(clientIP, playerId, serverBase) {
            const audio = document.getElementById(playerId);
            const source = audio.querySelector('source');
            const statusElement = document.getElementById(`status_${playerId}`);
            const infoElement = document.getElementById(`info_${playerId}`);
            
            try {
                statusElement.textContent = 'L√§dt...';
                infoElement.textContent = 'Stream wird geladen...';
                
                // Always use HTTPS server for streams (port 6969), not the dashboard server
                const streamBaseUrl = `https://${window.location.hostname}:6969`;
                let streamUrl = `${streamBaseUrl}/client/${clientIP}/stream?t=${Date.now()}`;
                source.src = streamUrl;
                audio.load();
                
                // Store player reference
                streamPlayers.set(playerId, { clientIP, isPlaying: false });
                
                audio.addEventListener('loadstart', () => {
                    statusElement.textContent = 'L√§dt...';
                    infoElement.textContent = 'Stream l√§dt...';
                });
                
                audio.addEventListener('canplay', () => {
                    statusElement.textContent = 'Bereit';
                    infoElement.textContent = 'Stream bereit zum Abspielen';
                });
                
                audio.addEventListener('play', () => {
                    statusElement.textContent = 'Spielt ab';
                    infoElement.textContent = 'Stream wird abgespielt';
                    const player = streamPlayers.get(playerId);
                    if (player) player.isPlaying = true;
                });
                
                audio.addEventListener('pause', () => {
                    statusElement.textContent = 'Pausiert';
                    infoElement.textContent = 'Stream pausiert';
                    const player = streamPlayers.get(playerId);
                    if (player) player.isPlaying = false;
                });
                
                audio.addEventListener('error', async (e) => {
                    console.error('Audio error for', clientIP, ':', e);
                    
                    // Try protocol fallback
                    const currentIsHTTPS = source.src.includes('https');
                    const currentPort = source.src.includes(':8081') ? '8081' : '6969';
                    
                    if (currentIsHTTPS && currentPort === '6969') {
                        // Try HTTP fallback
                        console.log('Trying HTTP fallback for', clientIP);
                        statusElement.textContent = 'Fallback...';
                        infoElement.textContent = 'Versuche HTTP Fallback...';
                        
                        const fallbackUrl = `${HTTP_FALLBACK}/client/${clientIP}/stream?t=${Date.now()}`;
                        source.src = fallbackUrl;
                        audio.load();
                    } else if (!currentIsHTTPS && currentPort === '8081') {
                        // Try HTTPS fallback
                        console.log('Trying HTTPS fallback for', clientIP);
                        statusElement.textContent = 'Fallback...';
                        infoElement.textContent = 'Versuche HTTPS Fallback...';
                        
                        const fallbackUrl = `${HTTPS_FALLBACK}/client/${clientIP}/stream?t=${Date.now()}`;
                        source.src = fallbackUrl;
                        audio.load();
                    } else {
                        statusElement.textContent = 'Fehler';
                        infoElement.textContent = 'Fehler beim Laden: ' + e.type;
                    }
                });
                
                // Try to play after a short delay
                setTimeout(() => {
                    audio.play().catch(err => {
                        console.log('Autoplay blocked for', clientIP);
                        infoElement.textContent = 'Klicke Play um zu starten (Autoplay blockiert)';
                    });
                }, 1000);
                
                updateRefreshTime(playerId);
                
            } catch (error) {
                statusElement.textContent = 'Fehler';
                infoElement.textContent = 'Fehler: ' + error.message;
                console.error('Error playing stream:', error);
            }
        }
        
        // Pause stream
        function pauseStream(playerId) {
            const audio = document.getElementById(playerId);
            audio.pause();
        }
        
        // Stop stream
        function stopStream(playerId) {
            const audio = document.getElementById(playerId);
            audio.pause();
            audio.currentTime = 0;
            const statusElement = document.getElementById(`status_${playerId}`);
            const infoElement = document.getElementById(`info_${playerId}`);
            statusElement.textContent = 'Gestoppt';
            infoElement.textContent = 'Stream gestoppt';
            
            const player = streamPlayers.get(playerId);
            if (player) player.isPlaying = false;
        }
        
        // Refresh stream
        function refreshStream(clientIP, playerId, serverBase) {
            const player = streamPlayers.get(playerId);
            if (player && player.isPlaying) {
                playStream(clientIP, playerId, serverBase);
            }
        }
        
        // Set volume
        function setVolume(playerId, value) {
            const audio = document.getElementById(playerId);
            const volumeDisplay = document.getElementById(`volume_${playerId}`);
            audio.volume = value / 100;
            volumeDisplay.textContent = value + '%';
        }
        
        // Stop all streams
        function stopAllStreams() {
            streamPlayers.forEach((player, playerId) => {
                stopStream(playerId);
            });
        }
        
        // Update refresh time
        function updateRefreshTime(playerId) {
            const refreshElement = document.getElementById(`refresh_${playerId}`);
            if (refreshElement) {
                refreshElement.textContent = new Date().toLocaleTimeString();
            }
        }
        
        // Auto refresh functionality
        function startAutoRefresh() {
            if (autoRefreshInterval) return;
            
            autoRefreshInterval = setInterval(() => {
                if (isAutoRefresh) {
                    refreshStreams();
                    
                    // Refresh active streams
                    streamPlayers.forEach((player, playerId) => {
                        if (player.isPlaying) {
                            refreshStream(player.clientIP, playerId);
                        }
                    });
                }
            }, 10000); // Every 10 seconds
        }
        
        function toggleAutoRefresh() {
            const btn = document.getElementById('autoRefreshBtn');
            isAutoRefresh = !isAutoRefresh;
            
            if (isAutoRefresh) {
                btn.textContent = '‚è∏Ô∏è Auto-Refresh';
                btn.style.background = 'linear-gradient(45deg, #FF6B6B, #4ECDC4)';
            } else {
                btn.textContent = '‚ñ∂Ô∏è Auto-Refresh';
                btn.style.background = 'linear-gradient(45deg, #666, #888)';
            }
        }
        
        // Show error message
        function showError(message) {
            const container = document.getElementById('streamsContainer');
            container.innerHTML = `<div class="error">‚ùå ${message}</div>`;
        }
        
        // Enhanced Player Functions
        const audioContexts = new Map();
        const visualizers = new Map();
        
        // Play enhanced stream with visualization
        async function playEnhancedStream(clientIP, playerId, serverBase) {
            const audio = document.getElementById(playerId);
            const statusElement = document.getElementById(`status_${playerId}`);
            const infoElement = document.getElementById(`info_${playerId}`);
            
            try {
                statusElement.textContent = 'L√§dt...';
                infoElement.textContent = 'Stream wird geladen...';
                
                // Always use HTTPS server for streams (port 6969), not the dashboard server
                const streamBaseUrl = `https://${window.location.hostname}:6969`;
                let streamUrl = `${streamBaseUrl}/client/${clientIP}/stream?t=${Date.now()}`;
                
                // Setup audio source
                const source = audio.querySelector('source') || audio.appendChild(document.createElement('source'));
                source.src = streamUrl;
                source.type = 'audio/webm';
                audio.load();
                
                // Setup audio visualization
                setupAudioVisualization(playerId, audio);
                
                // Store player reference
                streamPlayers.set(playerId, { clientIP, isPlaying: false });
                
                // Event listeners
                audio.addEventListener('loadstart', () => {
                    statusElement.textContent = 'L√§dt...';
                    infoElement.textContent = 'Stream l√§dt...';
                });
                
                audio.addEventListener('canplay', () => {
                    statusElement.textContent = 'Bereit';
                    infoElement.textContent = 'Stream bereit zum Abspielen';
                });
                
                audio.addEventListener('play', () => {
                    statusElement.textContent = 'Spielt ab';
                    infoElement.textContent = 'Live-Stream aktiv';
                    const player = streamPlayers.get(playerId);
                    if (player) player.isPlaying = true;
                    startVisualization(playerId);
                });
                
                audio.addEventListener('pause', () => {
                    statusElement.textContent = 'Pausiert';
                    infoElement.textContent = 'Stream pausiert';
                    const player = streamPlayers.get(playerId);
                    if (player) player.isPlaying = false;
                    stopVisualization(playerId);
                });
                
                audio.addEventListener('timeupdate', () => {
                    updatePlayerTime(playerId, audio);
                });
                
                audio.addEventListener('error', async (e) => {
                    console.error('Audio error for', clientIP, ':', e);
                    statusElement.textContent = 'Fehler';
                    infoElement.textContent = 'Stream-Fehler aufgetreten';
                    stopVisualization(playerId);
                });
                
                // Try to play
                setTimeout(() => {
                    audio.play().catch(err => {
                        console.log('Autoplay blocked for', clientIP);
                        infoElement.textContent = 'Klicke Play um zu starten (Autoplay blockiert)';
                    });
                }, 1000);
                
                updateRefreshTime(playerId);
                
            } catch (error) {
                statusElement.textContent = 'Fehler';
                infoElement.textContent = 'Fehler: ' + error.message;
                console.error('Error playing enhanced stream:', error);
            }
        }
        
        // Pause enhanced stream
        function pauseEnhancedStream(playerId) {
            const audio = document.getElementById(playerId);
            audio.pause();
            stopVisualization(playerId);
        }
        
        // Stop enhanced stream
        function stopEnhancedStream(playerId) {
            const audio = document.getElementById(playerId);
            audio.pause();
            audio.currentTime = 0;
            stopVisualization(playerId);
        }
        
        // Set enhanced volume
        function setEnhancedVolume(playerId, volume) {
            const audio = document.getElementById(playerId);
            const volumeSpan = document.getElementById(`volume_${playerId}`);
            audio.volume = volume / 100;
            volumeSpan.textContent = volume + '%';
        }
        
        // Setup audio visualization
        function setupAudioVisualization(playerId, audio) {
            const canvas = document.getElementById(`visualizer_${playerId}`);
            const ctx = canvas.getContext('2d');
            
            // Set canvas size
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            try {
                // Create audio context and analyzer
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const analyzer = audioContext.createAnalyser();
                const source = audioContext.createMediaElementSource(audio);
                
                source.connect(analyzer);
                analyzer.connect(audioContext.destination);
                
                analyzer.fftSize = 256;
                const bufferLength = analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                audioContexts.set(playerId, { audioContext, analyzer, dataArray, ctx, canvas });
                
            } catch (error) {
                console.warn('Audio visualization not supported:', error);
            }
        }
        
        // Start visualization
        function startVisualization(playerId) {
            const visualizer = audioContexts.get(playerId);
            if (!visualizer) return;
            
            const { analyzer, dataArray, ctx, canvas } = visualizer;
            
            function draw() {
                if (!streamPlayers.get(playerId)?.isPlaying) return;
                
                requestAnimationFrame(draw);
                
                analyzer.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = (canvas.width / dataArray.length) * 2.5;
                let barHeight;
                let x = 0;
                
                for (let i = 0; i < dataArray.length; i++) {
                    barHeight = (dataArray[i] / 255) * canvas.height;
                    
                    const r = barHeight + 25 * (i / dataArray.length);
                    const g = 250 * (i / dataArray.length);
                    const b = 50;
                    
                    ctx.fillStyle = `rgb(${r},${g},${b})`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
                
                // Update volume bars
                updateVolumeBars(playerId, dataArray);
            }
            
            draw();
        }
        
        // Stop visualization
        function stopVisualization(playerId) {
            const visualizer = audioContexts.get(playerId);
            if (!visualizer) return;
            
            const { ctx, canvas } = visualizer;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Clear volume bars
            const volumeBars = document.getElementById(`volumeBars_${playerId}`);
            if (volumeBars) {
                const bars = volumeBars.querySelectorAll('.volume-bar');
                bars.forEach(bar => bar.style.height = '2px');
            }
        }
        
        // Update volume bars
        function updateVolumeBars(playerId, dataArray) {
            const volumeBars = document.getElementById(`volumeBars_${playerId}`);
            if (!volumeBars) return;
            
            const bars = volumeBars.querySelectorAll('.volume-bar');
            const segmentSize = Math.floor(dataArray.length / bars.length);
            
            bars.forEach((bar, index) => {
                let sum = 0;
                for (let i = index * segmentSize; i < (index + 1) * segmentSize; i++) {
                    sum += dataArray[i] || 0;
                }
                const average = sum / segmentSize;
                const height = Math.max(2, (average / 255) * 20);
                bar.style.height = height + 'px';
            });
        }
        
        // Update player time display
        function updatePlayerTime(playerId, audio) {
            const timeElement = document.getElementById(`time_${playerId}`);
            if (timeElement && audio.duration) {
                const minutes = Math.floor(audio.currentTime / 60);
                const seconds = Math.floor(audio.currentTime % 60);
                timeElement.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
            } else if (timeElement) {
                // For live streams, show "LIVE"
                timeElement.textContent = 'LIVE';
            }
        }
        
        // RTP Stream Functions
        async function startRTPStream(clientIP, playerId) {
            try {
                const response = await fetch(`${SERVER_BASE}/api/rtp/start`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ client_ip: clientIP })
                });
                
                const result = await response.json();
                const statusElement = document.getElementById(`rtpStatus_${playerId}`);
                const urlElement = document.getElementById(`rtpUrl_${playerId}`);
                
                if (result.success) {
                    statusElement.textContent = 'Aktiv';
                    statusElement.style.color = '#4ECDC4';
                    urlElement.textContent = result.rtp_url;
                } else {
                    throw new Error(result.error || 'RTP Start fehlgeschlagen');
                }
                
            } catch (error) {
                console.error('RTP start error:', error);
                alert('RTP Stream konnte nicht gestartet werden: ' + error.message);
            }
        }
        
        async function stopRTPStream(clientIP, playerId) {
            try {
                const response = await fetch(`${SERVER_BASE}/api/rtp/stop`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ client_ip: clientIP })
                });
                
                const result = await response.json();
                const statusElement = document.getElementById(`rtpStatus_${playerId}`);
                
                if (result.success) {
                    statusElement.textContent = 'Gestoppt';
                    statusElement.style.color = '#FF6B6B';
                } else {
                    throw new Error(result.error || 'RTP Stop fehlgeschlagen');
                }
                
            } catch (error) {
                console.error('RTP stop error:', error);
                alert('RTP Stream konnte nicht gestoppt werden: ' + error.message);
            }
        }
        
        function copyRTPUrl(clientIP, playerId) {
            const urlElement = document.getElementById(`rtpUrl_${playerId}`);
            const url = urlElement.textContent;
            
            // Fallback for HTTP contexts where clipboard API is not available
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(url).then(() => {
                    alert('RTP URL kopiert: ' + url);
                }).catch(err => {
                    console.error('Clipboard error:', err);
                    fallbackCopyToClipboard(url);
                });
            } else {
                fallbackCopyToClipboard(url);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            // Create temporary textarea
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                alert('RTP URL kopiert: ' + text);
            } catch (err) {
                console.error('Fallback copy failed:', err);
                prompt('RTP URL (bitte manuell kopieren):', text);
            }
            
            document.body.removeChild(textArea);
        }
        
        // Live Soundwave Functions
        const soundwaveData = new Map();
        const soundwaveIntervals = new Map();
        
        function startLiveSoundwaves() {
            // Start updating soundwaves for all active stream cards
            const interval = setInterval(updateAllSoundwaves, 200); // 5 FPS
            soundwaveIntervals.set('global', interval);
        }
        
        function stopLiveSoundwaves() {
            soundwaveIntervals.forEach(interval => clearInterval(interval));
            soundwaveIntervals.clear();
        }
        
        async function updateAllSoundwaves() {
            try {
                // Get audio levels from API
                const response = await fetch(`${SERVER_BASE}/api/audio/levels`);
                const data = await response.json();
                
                if (data.success && data.levels) {
                    // Update soundwave for each client
                    Object.entries(data.levels).forEach(([clientIP, levelData]) => {
                        const playerId = `player_${clientIP.replace(/\./g, '_')}`;
                        updateSoundwaveVisualization(playerId, clientIP, levelData);
                    });
                    
                    // Update inactive clients
                    streamPlayers.forEach((player, playerId) => {
                        if (!data.levels[player.clientIP]) {
                            updateSoundwaveVisualization(playerId, player.clientIP, {
                                level: 0, peak: 0, active: false
                            });
                        }
                    });
                }
            } catch (error) {
                console.error('Soundwave update error:', error);
            }
        }
        
        function updateSoundwaveVisualization(playerId, clientIP, levelData) {
            const canvas = document.getElementById(`soundwave_${playerId}`);
            const infoElement = document.getElementById(`soundwaveInfo_${playerId}`);
            const levelElement = document.getElementById(`audioLevel_${playerId}`);
            const peakElement = document.getElementById(`audioPeak_${playerId}`);
            const levelBars = document.getElementById(`levelBars_${playerId}`);
            
            if (!canvas || !infoElement || !levelElement || !peakElement || !levelBars) {
                return;
            }
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;
            
            // Update info display
            if (levelData.active) {
                infoElement.textContent = `üîä Live Signal`;
                infoElement.style.color = '#4ECDC4';
                levelElement.textContent = `Level: ${levelData.level}%`;
                peakElement.textContent = `Peak: ${levelData.peak}%`;
            } else {
                infoElement.textContent = `üîá Kein Signal`;
                infoElement.style.color = '#FF6B6B';
                levelElement.textContent = `Level: 0%`;
                peakElement.textContent = `Peak: 0%`;
            }
            
            // Update level bars
            const bars = levelBars.querySelectorAll('.level-bar');
            const activeBarCount = Math.floor((levelData.level / 100) * bars.length);
            
            bars.forEach((bar, index) => {
                if (index < activeBarCount && levelData.active) {
                    const height = Math.max(2, Math.random() * 25 + (levelData.level / 100) * 20);
                    bar.style.height = height + 'px';
                    bar.style.opacity = '1';
                } else {
                    bar.style.height = '2px';
                    bar.style.opacity = '0.3';
                }
            });
            
            // Draw soundwave on canvas
            drawSoundwave(ctx, canvas, levelData);
            
            // Store data for history
            if (!soundwaveData.has(playerId)) {
                soundwaveData.set(playerId, []);
            }
            
            const history = soundwaveData.get(playerId);
            history.push({
                level: levelData.level,
                peak: levelData.peak,
                timestamp: Date.now()
            });
            
            // Keep only last 100 data points
            if (history.length > 100) {
                history.shift();
            }
        }
        
        function drawSoundwave(ctx, canvas, levelData) {
            const width = canvas.width;
            const height = canvas.height;
            
            // Clear canvas
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.fillRect(0, 0, width, height);
            
            if (!levelData.active) {
                // Draw flat line when inactive
                ctx.strokeStyle = '#FF6B6B';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
                return;
            }
            
            // Draw animated soundwave
            const time = Date.now() / 1000;
            const amplitude = (levelData.level / 100) * (height / 4);
            const frequency = 2 + (levelData.peak / 100) * 3;
            
            ctx.strokeStyle = '#4ECDC4';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let x = 0; x < width; x++) {
                const progress = x / width;
                const wave1 = Math.sin((progress * frequency + time) * Math.PI * 2) * amplitude;
                const wave2 = Math.sin((progress * frequency * 1.5 + time * 1.3) * Math.PI * 2) * amplitude * 0.5;
                const y = height / 2 + wave1 + wave2;
                
                if (x === 0) {
                    ctx.moveTo(x, y);
                } else {
                    ctx.lineTo(x, y);
                }
            }
            
            ctx.stroke();
            
            // Add glow effect
            ctx.shadowColor = '#4ECDC4';
            ctx.shadowBlur = 10;
            ctx.stroke();
            ctx.shadowBlur = 0;
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            initDashboard();
            startLiveSoundwaves();
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (autoRefreshInterval) {
                clearInterval(autoRefreshInterval);
            }
            
            // Stop soundwaves
            stopLiveSoundwaves();
            
            // Cleanup audio contexts
            audioContexts.forEach((context, playerId) => {
                if (context.audioContext) {
                    context.audioContext.close();
                }
            });
        });
    </script>
</body>
</html>